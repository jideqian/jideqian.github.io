<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="Jiye Qian" />
    <title>Aquamacs速查手册</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="Jiye Qian" type="application/atom+xml" />
    <link rel="stylesheet" href="/assets/css/style.css" />
    <link rel="stylesheet" href="/assets/css/pygments/default.css" />
    <link rel="stylesheet" href="/assets/css/coderay.css" />

    <script type="text/javascript" src="/assets/js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript" src="/assets/js/outliner.js"></script>

    <!-- MathJax for LaTeX -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        "HTML-CSS": { extensions: ["handle-floats.js"] },
        TeX: { equationNumbers: { autoNumber: "AMS" } },
        tex2jax: {
            inlineMath: [['$$$', '$$$'], ['$', '$'], ['\\(', '\\)']],
            processEscapes: true
        }
    });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG"></script> -->
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Faa6c4cba1a96584b9d529cb356a6aef2' type='text/javascript'%3E%3C/script%3E"));
</script>


  </head>
<!--  <body>
-->
  <script type="text/javascript">
    function setTimeSpan(){
    	var date = new Date();
    	timeSpan.innerText=date.format('yyyy-MM-dd hh:mm:ss');
    }

    Date.prototype.format = function(format)
		{
    var o =
    	{
    	    "M+" : this.getMonth()+1, //month
    	    "d+" : this.getDate(),    //day
    	    "h+" : this.getHours(),   //hour
    	    "m+" : this.getMinutes(), //minute
    	    "s+" : this.getSeconds(), //second
    	    "q+" : Math.floor((this.getMonth()+3)/3),  //quarter
    	    "S" : this.getMilliseconds() //millisecond
    	}
    	if(/(y+)/.test(format))
    	format=format.replace(RegExp.$1,(this.getFullYear()+"").substr(4 - RegExp.$1.length));
    	for(var k in o)
    	if(new RegExp("("+ k +")").test(format))
    	format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length));
    	return format;
		}
  </script>
  <body onLoad="setInterval(setTimeSpan,1000);">
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>Aquamacs速查手册</h1>
        </header>
        <nav id="real_nav">
        <span><a title="home" class="" href="/">home</a></span>
        <span><a title="categories" class="" href="/categories/">categories</a></span>
        <span><a title="tags" class="" href="/tags/">tags</a></span>
        <span><a title="logs" class="" href="/logs/">Log</a></span>
        <span><a title="about" class="" href="/about/">about</a></span>
        <span><a title="subscribe by RSS" class="" href="/feed/">Subscribe</a></span>
        </nav>
        <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2012-07-04">2012-07-04</time>
</span>

 |
<span class="categories">
  categories
  
  <a href="/categories/#振导社会" title="振导社会">振导社会</a>&nbsp;
  
</span>


 |
<span class="tags">
  tags
  
  <a href="/tags/#程序设计" title="程序设计">程序设计</a>&nbsp;
  
  <a href="/tags/#Emacs" title="Emacs">Emacs</a>&nbsp;
  
  <a href="/tags/#Lisp" title="Lisp">Lisp</a>&nbsp;
  
  <a href="/tags/#工具" title="工具">工具</a>&nbsp;
  
</span>

</section>
<section class="post">
<p><a href="http://Aquamacs.org">Aquamacs</a>是<a href="http://www.gnu.org/software/emacs/">GNU Emacs</a>在OSX系统的一个发行版，除了支持Emacs标准快捷键外，也支持与OSX系统兼容的快捷键。因此，本文的大多数内容对Emacs也实用。</p>

<blockquote>
  <p>While the useful Emacs key bindings are supported and Emacs packages usually just work, Aquamacs is adapted to be comparable to younger text editors (than Emacs). It also comes with a range of packages that give you greater comfort in editing certain types of files.</p>
</blockquote>

<!--more-->

<h2 id="section">基础知识</h2>

<h3 id="section-1">键盘对应关系</h3>

<table>
  <thead>
    <tr>
      <th>Emacs</th>
      <th>Mac</th>
      <th>PC</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>META</td>
      <td>esc/option</td>
      <td>Alt</td>
    </tr>
    <tr>
      <td>CTRL</td>
      <td>command</td>
      <td>Ctrl</td>
    </tr>
  </tbody>
</table>

<h3 id="section-2">获取帮助的快捷键</h3>

<table>
  <thead>
    <tr>
      <th>快捷键</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>C-h t</code></td>
      <td>emacs tutorial</td>
    </tr>
    <tr>
      <td><code>C-h i</code></td>
      <td>emacs info</td>
    </tr>
    <tr>
      <td><code>C-h r</code></td>
      <td>emacs manual</td>
    </tr>
    <tr>
      <td><code>C-h f &lt;函数名&gt;</code></td>
      <td>函数的帮助信息</td>
    </tr>
    <tr>
      <td><code>C-h v &lt;变量名&gt;</code></td>
      <td>变量的帮助信息</td>
    </tr>
    <tr>
      <td><code>C-h k &lt;快捷键&gt;</code></td>
      <td>快捷键的帮助信息</td>
    </tr>
  </tbody>
</table>

<p>Emacs最常用功能可通过简明的<a href="http://www.damtp.cam.ac.uk/user/eglen/ess11/resources/emacs-refcard.pdf">GNU Emacs Reference Card</a>学习。</p>

<h3 id="info">info的快捷键</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: right">功能</th>
      <th style="text-align: right">快捷键</th>
      <th style="text-align: left">快捷键</th>
      <th style="text-align: left">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">上一节点</td>
      <td style="text-align: right"><code>p</code></td>
      <td style="text-align: left"><code>n</code></td>
      <td style="text-align: left">下一节点</td>
    </tr>
    <tr>
      <td style="text-align: right">上一菜单</td>
      <td style="text-align: right"><code>[</code></td>
      <td style="text-align: left"><code>]</code></td>
      <td style="text-align: left">下一菜单（菜单前标有*）</td>
    </tr>
    <tr>
      <td style="text-align: right">交叉引用跳转</td>
      <td style="text-align: right"><code>f</code></td>
      <td style="text-align: left"><code>l</code></td>
      <td style="text-align: left">交叉引用返回</td>
    </tr>
    <tr>
      <td style="text-align: right">向上翻页</td>
      <td style="text-align: right"><code>DELETE</code></td>
      <td style="text-align: left"><code>SPACE</code></td>
      <td style="text-align: left">向下翻页</td>
    </tr>
    <tr>
      <td style="text-align: right">info tutorial</td>
      <td style="text-align: right"><code>h</code></td>
      <td style="text-align: left"><code>C-l</code></td>
      <td style="text-align: left">当前节点循环翻页</td>
    </tr>
    <tr>
      <td style="text-align: right">上级菜单</td>
      <td style="text-align: right"><code>u</code></td>
      <td style="text-align: left"><code>b</code></td>
      <td style="text-align: left">回到节首</td>
    </tr>
    <tr>
      <td style="text-align: right">跳到指定节点</td>
      <td style="text-align: right"><code>g</code></td>
      <td style="text-align: left"><code>m</code></td>
      <td style="text-align: left">菜单</td>
    </tr>
    <tr>
      <td style="text-align: right">回到info总目录</td>
      <td style="text-align: right"><code>d</code></td>
      <td style="text-align: left"><code>t</code></td>
      <td style="text-align: left">回到顶层菜单</td>
    </tr>
  </tbody>
</table>

<p>info兼容Emacs快捷键。</p>

<!--
###Emacs戏法

 快捷键 | 功能
---- | ----
`C-u <数字> 快捷键`| 为快捷键传送参数
`M-<数字> 快捷键`| 执行快捷键`<数字>`次

如何输入`<数字>`个数字？

拼写检查：   
ispell、flyspell-mode

Tabs and Windows：
一个tab对应于一个buffer，OSX切换tab的快捷键是command+数字
Aquamacs配置文件的位置

可用C-h v load-path查看  
-->

<h3 id="osxemacs">OSX系统和Emacs术语对应关系</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">OSX Term</th>
      <th>Emacs Term</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Window</td>
      <td>Frame</td>
    </tr>
    <tr>
      <td style="text-align: left">Tab/pane</td>
      <td>Window</td>
    </tr>
    <tr>
      <td style="text-align: left">Document</td>
      <td>Buffer</td>
    </tr>
    <tr>
      <td style="text-align: left">Cursor</td>
      <td>Point</td>
    </tr>
    <tr>
      <td style="text-align: left">Mouse pointer</td>
      <td>Pointer</td>
    </tr>
    <tr>
      <td style="text-align: left">Keyboard shortcut</td>
      <td>Key (binding)</td>
    </tr>
  </tbody>
</table>

<h3 id="aquamacs">Aquamacs相关文件</h3>
<p>插件目录： </p>

<div class="highlight"><pre><code class="bash">~/Library/Application Support/Aquamacs Emacs/myPlugin
</code></pre></div>

<p>配置文件目录：</p>

<div class="highlight"><pre><code class="bash">/Library/Application Support/Aquamacs Emacs/  
/Library/Preferences/Aquamacs Emacs/  
~/Library/Preferences/Aquamacs Emacs/  
</code></pre></div>

<p>用户自定义配置文件：</p>

<div class="highlight"><pre><code class="bash">~/.emacs
~/Library/Preferences/Aquamacs Emacs/Preferences.el
</code></pre></div>

<p>当然，用户可以在配置文件中指定目录和相关文件位置。</p>

<h2 id="emacs-lisplisp--list-processing">Emacs Lisp基本语法（LISP = LISt Processing）</h2>

<p>elisp是定义emacs配置文件的lisp方言。在lisp中，一切皆以括号<code>( )</code>的形式存在。</p>

<h3 id="section-3">数据类型</h3>

<p>elisp 里的对象都是有类型的，而且每一个对象知道自己是什类型。内建的emacs数据类型称为primitive types，包括：整数、浮点数、cons、符号(symbol）、字符串、向量（vector）、散列表（hash-table）、subr（内建函数（比如cons、if、and之类）、byte-code function，和其它特殊类型，例如缓冲区（buffer）。</p>

<ul>
  <li>数字
    <ul>
      <li>分为整数和浮点数两种类型</li>
      <li>运算符：<code>+</code><code>-</code><code>*</code><code>/</code><code>%</code><code>abs</code><code>mod</code></li>
      <li>比较操作符：<code>&lt;</code><code>&gt;</code><code>&gt;=</code><code>&lt;=</code><code>=</code><code>/=</code></li>
      <li>舍入函数：<code>truncate</code><code>floor</code><code>ceiling</code><code>round</code></li>
      <li>其它常用函数：<code>sin</code><code>cos</code><code>sqrt</code><code>exp</code><code>log</code><code>random</code></li>
    </ul>
  </li>
  <li>字符与字符串
    <ul>
      <li>字符的读入语法是<code>?&lt;字符&gt;</code></li>
      <li>常用的函数：<code>string</code><code>substring</code><code>string-to-number</code><code>up case</code><code>string-match</code></li>
    </ul>
  </li>
  <li>cons cell和list（列表）
    <ul>
      <li>cons cell由car和cdr两部分组成，car指向当前节点，cdr指向下一节点或<code>nil</code>，cons cell通过<code>.</code>将两部分分开（dotted pair）。</li>
      <li>list按链表的形式存贮，每个节点是一个cons cell，<code>'(a b)</code>可由<code>'(a . (b . nil))</code>构建。</li>
      <li>列表前的单引号<code>'</code>告诉lisp不要对列表进行处理，如列表前没有单引号，列表的第一个元素是函数，<code>'</code>与<code>quote</code>函数等价，即<code>'(a b)</code>与<code>(quote (a b))</code>等价。</li>
      <li>生成一个cons cell用<code>cons</code>函数，它也是为list增加元素的方法。</li>
    </ul>
  </li>
  <li>序列和数组
    <ul>
      <li>序列是列表和数组的统称，数组包括：vector（向量）、string（字符串）、char-table和bool-vector。</li>
      <li>数组的每个元素都对应一个下标，第一个元素下标为0；数组自求值；数组的元素都可用<code>aref</code>来访问，用<code>aset</code>来设置。</li>
      <li>向量是通用的数组，元素是任意对象；字符串是特殊的数组，元素只能是字符。</li>
      <li>创建向量可以用<code>vector</code>函数：<code>(vector 'foo 23 [bar baz] "rats")</code>。</li>
    </ul>
  </li>
  <li>符号
    <ul>
      <li>符号是有名字的对象，相当于C语言的指针，符号名可含有任何字符。</li>
      <li>通过符号可以得到与符号相关的信息，比如值、函数、属性列表等。</li>
      <li>符号名唯一，在elisp中符号与名字通过obarray表关联。</li>
      <li><code>intern</code>函数查找或加入一个名字到obarray，返回对应符号，默认是全局obarray，也可指定obarray，<code>intern-soft</code>只是查找符号。当名字不在obarray时，<code>intern-soft</code>返回<code>nil</code>，而<code>intern</code>会加入符号到obarray中。</li>
      <li><code>unintern</code>函数去除在obarray中的符号，成功则返回<code>t</code>，未找到则返回<code>nil</code>。</li>
      <li>lisp每读入一个符号都会<code>intern</code>到obarray中，在符号前加入<code>#:</code>可避免加入。</li>
      <li>符号有4个组成部分：
        <ul>
          <li>名字，用<code>symbol-name</code>访问；</li>
          <li>值，用<code>set</code>设置，用<code>symbol-value</code>访问；</li>
          <li>函数，用<code>fset</code>设置，用<code>symbol-function</code>访问；</li>
          <li>属性列表，用<code>get</code>访问，用<code>put</code>修改，用<code>symbol-plist</code>得到所有属性列表。</li>
        </ul>
      </li>
      <li><code>setq</code>是一个使用<code>set</code>的宏，<code>(setq sym val)</code>代表<code>(set (quote sym) val)</code>，q表示quoted，<code>setq</code>只能设置obarray中的变量。</li>
      <li><code>boundp</code>测试符号值是否设置过，如果是则返回<code>t</code>，否则返回<code>nil</code>；测试函数用<code>fboundp</code>。</li>
    </ul>
  </li>
</ul>

<h3 id="section-4">求值规则</h3>

<p>一个要求值的lisp对象称为表达式（form），分为三种：符号、列表和其它类型。表达式的求值规则如下：</p>

<ul>
  <li>自求值表达式。包括：数字、字符串、向量，以及<code>t</code>和<code>nil</code>。</li>
  <li>符号。符号的求值结果就是它的值，如果它没有值，抛出void-variable的错误。</li>
  <li>列表表达式。根据第一个元素可分为：
    <ul>
      <li>函数调用：第一个元素若为符号，解释器查找该符号的函数值，若其值仍为符号，继续查找，直到某个符号的函数值是一个lisp函数（lambda函数）、byte-code函数、原子函数（primitive function）、宏、特殊表达式或autoload对象，这一过程称为symbol function indirection。</li>
      <li>宏调用：第一个元素是宏对象，列表里的其它元素不会立即求值，先对宏扩展。</li>
      <li>特殊表达式：第一个元素是特殊表达式时，参数可能不会全求值，每个特殊表达式都有其对应的求值规则，如<code>cond</code>。</li>
    </ul>
  </li>
</ul>

<h3 id="section-5">变量</h3>

<p>变量按作用域分为：全局变量、let绑定的局部变量和buffer-local变量。</p>

<p>全局变量无需声明，可以直接采用如下的方式赋值：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">setq</span> <span class="nv">foo</span> <span class="s">&quot;I&#39;m foo&quot;</span><span class="p">)</span>
</code></pre></div>

<p>另一个声明变量的方式是：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">variable-name</span> <span class="nv">value</span>
  <span class="s">&quot;document string&quot;</span><span class="p">)</span>
</code></pre></div>

<p>如果在声明之前，变量已经赋值，声明不会改变变量的赋值。</p>

<p>局部变量用<code>let</code>和<code>let*</code>进行绑定。let的绑定形式是：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">bindings</span><span class="p">)</span>
  <span class="nv">body</span><span class="p">)</span>
</code></pre></div>

<p>例如：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">circle-area</span> <span class="p">(</span><span class="nv">radix</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pi</span> <span class="mf">3.1415926</span><span class="p">)</span> <span class="nv">erea</span><span class="p">)</span>
    <span class="p">(</span><span class="k">setq</span> <span class="nv">area</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="nv">radix</span> <span class="nv">radix</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;半径为%.2f的圆，面积是%.2f。&quot;</span> <span class="nv">radix</span> <span class="nv">area</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">circle-area</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<p><code>let*</code>与<code>let</code>唯一不同的是，在声明中就能使用前面声明的变量。使用方式如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">circle-area</span> <span class="p">(</span><span class="nv">radix</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">pi</span> <span class="mf">3.1415926</span><span class="p">)</span>
	 <span class="p">(</span><span class="nv">area</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">pi</span> <span class="nv">radix</span> <span class="nv">radix</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;半径为%.2f的圆，面积是%.2f。&quot;</span> <span class="nv">radix</span> <span class="nv">area</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">circle-area</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<p>局部变量的绑定不能超过一定的层数。</p>

<p>emacs有如此丰富的模式，各缓冲区之间相互不冲突，很大程度上归功于一个特殊的局部变量buffer-local。声明buffer-local变量的方法：</p>

<ul>
  <li><code>make-variable-buffer-local</code> 在所有的缓冲区都产生一个buffer-local变量。</li>
  <li><code>make-local-variable</code> 所在的缓冲区产生一个局部变量。</li>
</ul>

<p>在指定缓冲区执行用<code>with-current-buffer</code>，调用形式如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">with-current-buffer</span> <span class="nv">buffer</span>
  <span class="nv">body</span><span class="p">)</span>
</code></pre></div>

<p>其中buffer既可是缓冲区对象也可是缓冲区名字，<code>get-buffer</code>可以用缓冲区名字得到缓冲区名字。</p>

<p>当一个符号作为全局变量有值，虽然用<code>make-local-variable</code>声明为buffer-local变量，但这个变量的值还是全局变量的值，这时全局变量的值也称为省却值，可用<code>defaule-value</code>访问。如果一个变量为buffer-local，这个缓冲区使用<code>sets</code>只能改变当前缓冲区的值，<code>setq-default</code>可以修改符号作为全局变量的值。测试变量是否为buffer-local可以用<code>local-variable-p</code>。在当前缓冲区获取其它缓冲区buffer-local变量用<code>buffer-local-value</code>：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">with-current-buffer</span> <span class="s">&quot;*Messages*&quot;</span>
  <span class="p">(</span><span class="nv">buffer-local-value</span> <span class="ss">&#39;foo</span> <span class="p">(</span><span class="nv">get-buffer</span> <span class="s">&quot;*scratch*&quot;</span><span class="p">)))</span>
</code></pre></div>

<p>变量命名的习惯：</p>

<ul>
  <li>-hook：特定情况下调用的函数，如关闭缓冲区、进入某个模式；</li>
  <li>-function：值为一个函数；</li>
  <li>-functions：值为一个函数列表；</li>
  <li>-flag：值为<code>nil</code>或non-nil；</li>
  <li>-predicate：值为一个判断的函数，返回<code>nil</code>或non-nil；</li>
  <li>-program或-command：一个程序或shell命令；</li>
  <li>-form：一个表达式；</li>
  <li>-forms：一个表达式列表；</li>
  <li>-map：一个按键映射（keymap）。</li>
</ul>

<h3 id="progn">顺序执行 <code>progn</code></h3>

<p>按顺序执行<code>progn</code>的每个参数，并返回最后一个执行的值。调用形式如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">progn</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div>

<h3 id="section-6">条件判断</h3>

<p><code>if</code>条件的定义形式：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">if</span> <span class="kt">condition</span>
    <span class="nv">then</span>
  <span class="nv">else</span><span class="p">)</span>
</code></pre></div>

<p><code>cond</code>分支跳转的定义形式：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">case1</span> <span class="nv">do-when-case1</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">case1</span> <span class="nv">do-when-case1</span><span class="p">)</span>
      <span class="o">...</span>
      <span class="p">(</span><span class="nv">caset</span> <span class="nv">do-when-caset</span><span class="p">))</span>
</code></pre></div>

<p>除此之外，还有<code>when</code>和<code>unless</code>用于条件判断。</p>

<h3 id="and-or-not">逻辑运算符 <code>and</code> <code>or</code> <code>not</code></h3>

<h3 id="section-7">循环</h3>

<p><code>while</code>循环的结构如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">while</span> <span class="kt">condition</span>
  <span class="nv">body</span><span class="p">)</span>
</code></pre></div>

<h3 id="section-8">函数</h3>

<p>函数对象包括：</p>

<ul>
  <li>函数：这里特指用lisp写的函数</li>
  <li>原子函数（primitive）：用C写的函数</li>
  <li>lambda表达式</li>
  <li>特殊表达式</li>
  <li>宏</li>
  <li>命令：能用<code>command-execute</code>调用，函数也是命令</li>
</ul>

<p>函数定义的形式：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="k">function</span> <span class="p">(</span><span class="nv">arguments-list</span><span class="p">)</span>
  <span class="s">&quot;document string&quot;</span>
  <span class="nv">body</span><span class="p">)</span>
</code></pre></div>

<p>每个函数都有一个返回值，这个返回值一般是函数定义里最后一个表达式的值。函数使用范例：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="err">高斯</span> <span class="p">(</span><span class="err">玄</span><span class="p">)</span>
  <span class="s">&quot;计算从 1 到 &#39;玄&#39; 之间所有整数之和，包括这两个数。&quot;</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="err">总和</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">(</span><span class="err">保存玄</span> <span class="err">玄</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="err">玄</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">setq</span> <span class="err">总和</span> <span class="p">(</span><span class="nb">+</span> <span class="err">总和</span> <span class="err">玄</span><span class="p">)</span>
	    <span class="err">玄</span> <span class="p">(</span><span class="nb">-</span> <span class="err">玄</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;从 1 加到 %d 值为： %d&quot;</span> <span class="err">保存玄</span> <span class="err">总和</span><span class="p">)))</span>
<span class="p">(</span><span class="err">高斯</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div>

<p>函数参数列表的形式：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">REQUIRED-VARS...</span>
 <span class="nv">[&amp;optional</span> <span class="nv">OPTIONAL-VARS...]</span>
 <span class="nv">[&amp;rest</span> <span class="nv">REST-VAR]</span><span class="p">)</span>
</code></pre></div>

<p>把必须提供的参数写在前面，可选参数写在后面，最后用一个符号表示剩余的所有参数。当提供了剩余参数时，所有参数以列表形式存放。</p>

<p>通常的函数调用通过<code>eval</code>进行，有时需要在运行时才决定使用什么样的函数，这就需要<code>funcall</code>和<code>apply</code>，这两个函数都是把其余的参数作为函数的参数进行调用。<code>funcall</code>是直接把参数传递给函数，而<code>apply</code>的最后一个参数是一个列表，传入的参数把列表平铺后再传给函数。以下是二者的区别：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">funcall</span> <span class="ss">&#39;list</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">z</span><span class="p">))</span>         <span class="c1">; =&gt; (x (y) (z))</span>
<span class="p">(</span><span class="nb">apply</span>   <span class="ss">&#39;list</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">z</span><span class="p">))</span>         <span class="c1">; =&gt; (x (y) z)</span>
</code></pre></div>

<p><code>lambda</code>表达式相当于匿名函数，定义方式是：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">arguments-list</span><span class="p">)</span>
  <span class="s">&quot;document string&quot;</span>
  <span class="nv">body</span><span class="p">)</span>
</code></pre></div>

<p>调用方式如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">name</span><span class="p">)</span>
	   <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;Hello, %s!&quot;</span> <span class="nv">name</span><span class="p">))</span> <span class="s">&quot;Emacser&quot;</span><span class="p">)</span>
</code></pre></div>

<p>也可以先把<code>lambda</code>表达式赋值给变量，然后再用<code>funcall</code>调用：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">setq</span> <span class="nv">foo</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">name</span><span class="p">)</span>
	    <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;Hello, %s!&quot;</span> <span class="nv">name</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">funcall</span> <span class="nv">foo</span> <span class="s">&quot;Emacser&quot;</span><span class="p">)</span>
</code></pre></div>

<p>递归函数的层数通过<code>max-specpdl-size</code>定义。</p>

<p>emacs运行时处于一个命令循环之中，不断从用户得到按键，然后调用命令来执行。lisp
编写的命令都含有一个<code>interactive</code>表达式指明了命令的参数。<code>interactive</code>参数的字符串的第一个代码字符代表了参数的类型，其后的字符串用于提示。如果命令有多个参数，可在提示字符串后用换行符分开，如下例：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">hello-world</span> <span class="p">(</span><span class="nv">name</span> <span class="nb">time</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">interactive</span> <span class="s">&quot;sWhat&#39;s you name? \nnWhat&#39;s the time?&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;Good %s, %s&quot;</span>
	   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">&lt;</span> <span class="nb">time</span> <span class="mi">13</span><span class="p">)</span> <span class="s">&quot;morning&quot;</span><span class="p">)</span>
		 <span class="p">((</span><span class="nb">&lt;</span> <span class="nb">time</span> <span class="mi">19</span><span class="p">)</span> <span class="s">&quot;afternoon&quot;</span><span class="p">)</span>
		 <span class="p">(</span><span class="no">t</span> <span class="s">&quot;evening&quot;</span><span class="p">))</span>
	   <span class="nv">name</span><span class="p">))</span>
</code></pre></div>

<p><code>interactive</code>用代码字符指定用户输入的方式可以用函数取代，比如<code>s</code>可用<code>read-string</code>代替如下：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">read-string</span> <span class="s">&quot;What&#39;s your name?&quot;</span> <span class="nv">usr-full-name</span><span class="p">)</span>
</code></pre></div>

<h2 id="aquamacs-1">Aquamacs常用配置</h2>

<p>Aquamacs已经完成了很多Emacs的基本配置，配置中需要的相关elisp函数，<a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Index.html">可查索引</a>。<a href="http://code.google.com/p/dea/">ahei</a>和<a href="https://github.com/alexott/emacs-configs">alexott</a>的配置是不错的参考，<a href="http://www.emacswiki.org/">emacswiki</a>和<a href="http://emacser.com/">emacser</a>可以找到很多相关资料。</p>

<p><a href="https://github.com/dimitri/el-get">el-get</a>是一个与debian的<code>apt-get</code>类似的emacs配置包管理器。</p>

<!--

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">set-default-font</span> <span class="s">&quot;Menlo Plus&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-fontset-font</span>
 <span class="p">(</span><span class="nv">frame-parameter</span> <span class="no">nil</span> <span class="ss">&#39;font</span><span class="p">)</span>
 <span class="ss">&#39;han</span>
 <span class="p">(</span><span class="nv">font-spec</span> <span class="ss">:family</span> <span class="s">&quot;Hiragino Sans GB&quot;</span><span class="p">))</span>
</code></pre></div>



<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">set-fontset-font</span> <span class="nv">NAME</span> <span class="nv">TARGET</span> <span class="nv">FONT-SPEC</span> <span class="k">&amp;optional</span> <span class="nv">FRAME</span> <span class="nv">ADD</span><span class="p">)</span>
</code></pre></div>



- `NAME`
- `TARGET`
- `FONT-SPEC`可以通过函数`font-spec`设置，参数和`set-face-attribute`的一致
- `FRME ADD`

查看当前用的字体可以用`describe-font`
-->

<h3 id="section-9">基本配置</h3>

<p>加载配置文件的路径：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">&#39;load-path</span> <span class="s">&quot;~/.emacs.d/site-lisp&quot;</span><span class="p">)</span>
</code></pre></div>

<p>绑定快捷键到函数/命令：</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&quot;C-c c&quot;</span><span class="p">)</span> <span class="ss">&#39;comment-region-or-line</span><span class="p">)</span> 
</code></pre></div>

<h3 id="section-10">代码补齐</h3>

<p>代码补齐就是根据当前的输入字符，补全或提示即将要输入的字符。补齐的原理就是根据当前已输入的字符，在特定的字典里匹配出即将要输入的字符，因此，生成用于补齐的字典是关键。这个字典来源有两方面：一是，用户提前提前定义，<a href="http://cx4a.org/software/auto-complete/">auto-complete</a>的用户定义字典在dict目录，<a href="https://github.com/capitaomorte/yasnippet">yasnippet</a>的代码片断预先定已在snippets目录，<a href="http://emacs-template.sourceforge.net">emacs-template</a>也有用于存放用户定义模板的templates目录；二是，程序自动分析生成，程序自动分析C/C++代码生成字典的有<a href="http://cedet.sourceforge.net/">cedet</a>和<a href="http://cx4a.org/software/gccsense/">gccsense</a>，<a href="http://rope.sourceforge.net/">rope</a>可分析python代码生成补齐字典，还有一些自动生成补齐字典的方案与程序语言无关，通过当前缓冲区、文件等信息，自动生成补齐字典，比如<a href="http://cx4a.org/software/auto-complete/">auto-complete</a>和<a href="http://nschum.de/src/emacs/company-mode/">company</a>。</p>

<p><a href="http://cx4a.org/software/auto-complete/">auto-complete</a>和<a href="http://nschum.de/src/emacs/company-mode/">company</a>主要功能是作为一个补齐前端，用户可以根据需要自定义用于补齐的后端驱动引擎，比如把<a href="https://github.com/capitaomorte/yasnippet">yasnippet</a>（<a href="http://www.emacswiki.org/cgi-bin/emacs-en/CompanyMode#toc8">解决company与yasnippet整合冲突的方案</a>）、<a href="http://rope.sourceforge.net/ropemacs.html">ropemacs</a>和<a href="http://cedet.sourceforge.net/">cedet</a>整合到它们的补齐方案中。<a href="http://cedet.sourceforge.net/">cedet</a>（Collection of Emacs Development Environment Tools）结合<a href="http://ecb.sourceforge.net/">ecb</a>（Emacs Code Browser）就是是一个功能完善的IDE方案，<a href="http://cedet.sourceforge.net/">cedet</a>既有不错的前端，后端有有强大的C/C++代码解析引擎，<a href="http://ecb.sourceforge.net/">ecb</a>方便阅读代码。</p>

<!--
my-cedet-complete和company可以共存   
all-auto-complete-settings和company不可共存   
all-auto-complete-settings和my-cedet-complete不可共存   

Symbol's function definition is void: company-pysmell  
-->

<h3 id="python">python的补齐方案</h3>
<p>python的补齐方案基于<a href="http://rope.sourceforge.net/">rope</a>，python补齐首先需要安装<a href="http://rope.sourceforge.net/">rope</a>、<a href="http://pypi.python.org/pypi/ropemode">ropemode</a>和<a href="https://github.com/pinard/Pymacs/">pymacs</a>（安装时需要手动将Pymacs.py拷贝到python的site-packages目录）。在此基础上，可以安装<a href="http://code.google.com/p/pysmell/">pysmell</a>、<a href="http://rope.sourceforge.net/ropemacs.html">ropemacs</a>或<a href="http://www.rwdev.eu/articles/emacspyeng">pycomplete</a>三者之一实现补齐。<a href="http://nschum.de/src/emacs/company-mode/">company</a>和<a href="http://cx4a.org/software/auto-complete/">auto-complete</a>这些补齐前端也可用<a href="http://code.google.com/p/pysmell/">pysmell</a>、<a href="http://rope.sourceforge.net/ropemacs.html">ropemacs</a>作为其补齐的引擎。</p>

<h2 id="section-11">参考资源</h2>

<p><a href="http://aquamacs.org/features.shtml">Aquamacs Emacs Manual</a>   <br />
<a href="http://www.emacswiki.org/">emacswiki</a>     <br />
<a href="http://www.gnu.org/software/emacs/manual/emacs.html">GNU Emacs manual</a> <br />
<a href="http://www.newsmth.net/bbsanc.php?path=%2Fgroups%2Fcomp.faq%2FEmacs%2Felisp%2Fhappierbee%2FM.1184679743.j0&amp;ap=64311">叶文彬：Elisp入门</a><br />
<a href="http://jianlee.ylinux.org/Computer/Emacs/elisp.html">Elisp 编程</a>   <br />
<a href="http://cs.gmu.edu/~sean/lisp/cons/">About Cons Cells</a>  <br />
<a href="http://en.wikipedia.org/wiki/S-expression">wikipedia: S-expression</a>    <br />
<a href="http://zh.wikipedia.org/wiki/LISP">wikipedia: LISP</a><br />
<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">wikipedia: Lisp (programming language)</a> <br />
<a href="http://www.gnu.org/software/emacs/emacs-lisp-intro/">An Introduction to Emacs Lisp Programming</a> <br />
<a href="http://www.gnu.org/software/emacs/manual/elisp.html">GNU Emacs Lisp Reference Manual</a>              <br />
<a href="http://emacser.com/emacs-gccsense.htm">Emacs补全利器：auto-complete+gccsense</a> <br />
<a href="http://emacser.com/cedet.htm">用CEDET浏览和编辑C++代码</a>  <br />
<a href="http://www.cnblogs.com/logicbaby/archive/2011/10/19/2217253.html">手把手教你emacs cedet C/C++自动补全</a> <br />
<a href="http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html">A Gentle introduction to CEDET</a> <br />
<a href="http://emacser.com/emacs-gccsense.htm">Emacs补全利器：auto-complete+gccsense</a>  </p>


</section>
<section align="right">
<br/>
<span>
  <a  href="/2012/07/host-your-pages-at-github-using-jekyll" class="pageNav"  >上一篇</a>
  &nbsp;&nbsp;&nbsp;
  <a  href="/2012/07/python-essential" class="pageNav"  >下一篇</a>
</span>
</section>

	
	<ul class="ds-recent-visitors"></ul>
	<div class="ds-thread" data-thread-key="/2012/07/introduction-to-aquamacs" data-url="http://jiyeqian.bitbucket.org/2012/07/introduction-to-aquamacs" data-title="Aquamacs速查手册">
	</div>
	<script type="text/javascript">
	var first_image = document.getElementsByClassName("post")[0].getElementsByTagName("img")[0]; 
	if (first_image != undefined) {
	document.getElementsByClassName("ds-thread")[0].setAttribute("data-image", first_image.src);
	}
	</script>
		
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"jiyeqian"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>


<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 72) {  // Left arrow and H
        
        url = '/2012/07/host-your-pages-at-github-using-jekyll';
        
        }
        else if (e.which == 39 || e.which == 76) {  // Right arrow and L
        
        <!-- url = 'http://jiyeqian.bitbucket.org/2012/07/python-essential'; -->
        url = '/2012/07/python-essential';
        
        } else if (e.which == 75) {  // K
          url = '#';
        } else if (e.which == 74) { // J
        url = '/2012/07/introduction-to-aquamacs/#timeSpan';
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

        </article>
        <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
            <img src="/assets/images/site/btt.png" />
        </a>
      </div>

    <footer>
        <p><small>
            Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> | Copyright 2014 - 2014 by <a href="/about/">Jiye Qian</a> | <span class="label label-info" id="timeSpan"></span></small></p>
    </footer>

    </div>
  </body>
</html>
